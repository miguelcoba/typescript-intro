<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>TypeScript - Introduction</title>

		<meta name="description" content="TypeScript - Introduction">
		<meta name="author" content="Miguel Cobá">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>TypeScript</h1>
					<h3>Introduction</h3>
					<p>
						<small><a href="http://miguelcoba.github.io">Miguel Cobá</a> / <a href="http://twitter.com/MiguelCobaMtz">@MiguelCobaMtz</a></small>
					</p>
				</section>

				<section>
					<section>
						<h1>TypeScript</h1>
						<h3>JavaScript that scales</h3>
						<p>TypeScript is a typed superset of Javascript that compiles to plain JavaScript</p>
						<p>Any browser. Any host. Any OS. Open source</p>
					</section>
					<section>
						<h1>Why?</h1>
						<p>Making JavaScript scale</p>
						<p>Easier to build and maintain medium to large applications</p>
					</section>
					<section>
						<h1>Advantages</h1>
						<h3>Great tooling enabled by static types</h3>
            <ul>
              <li>Statement completion</li>
              <li>Go to definition</li>
						  <li>Refactorings</li>
            </ul>
					</section>
					<section>
						<h1>Advantages</h1>
						<h3>Features from the future, today</h3>
            <ul>
              <li>Classes</li>
              <li>Lambda function</li>
            </ul>
					</section>
				</section>

				<section>
					<section>
						<h2>Install</h2>
						<pre><code class="shell" data-trim style="font-size: 18px;">
npm install -g typescript
						</code></pre>
					</section>
					<section>
						<h2>Verify installation</h2>
						<pre><code class="shell" data-trim style="font-size: 18px;">
tsc -v
Version 1.8.10
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h1>Language</h1>
					</section>
				</section>

				<section>
					<section>
						<h1>Type annotations</h1>
            <p>Lightweight ways to record the intended contract of the function or variable</p>
					</section>
				</section>

				<section>
					<section>
						<h1>Basic Types</h1>
					</section>

					<section>
						<h2>boolean</h2>
            <p></p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
let isEnabled: boolean = false;
						</code></pre>
					</section>

					<section>
						<h2>number</h2>
            <p></p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
let decimal: number = 6;
let hex: number = 0xf00d;
let binary: number = 0b1010;
let octal: number = 0o744;
						</code></pre>
					</section>

					<section>
						<h2>string</h2>
            <h3>Normal strings</h3>
            <ul>
              <li>Delimited by double quotes (") or single quotes (')</li>
            </ul>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
let name: string = "John";
name = 'John Smith';
						</code></pre>
					</section>

					<section>
						<h2>string</h2>
            <h3>Template strings</h3>

            <ul>
              <li>Delimited by (`)</li>
              <li>Can contain embedded expressions: ${ expr }</li>
            </ul>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
let fullName: string = `Miguel Cobá`;
let age: number = 36;
let greeting: string = `Hello, my name is ${ fullName }.

I will be ${ age + 1 } years old next month.`
						</code></pre>
					</section>

					<section>
						<h2>array</h2>
            <p>All the elements must be of the same type</p>
            <h4>Type + []</h4>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
let list: number[] = [1, 2, 3];
						</code></pre>

            <h4>Generic array type: Array&lt;elemType&gt;</h4>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
let list: Array&lt;number&gt; = [1, 2, 3];
						</code></pre>
					</section>

					<section>
						<h2>tuple</h2>
            <p>Allow you to express an array where the type of a fixed number of elements is known, but need not be the same</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
// Declare a tuple type for a pair of string and number
let x: [string, number];
// Initialize it
x = ["hello", 10]; // OK
// Initialize it incorrectly
x = [10, "hello"]; // Error
						</code></pre>
					</section>

					<section>
						<h2>enum</h2>
            <p>An enum is a way of giving more friendly names to sets of numeric values</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
// By default, enums begin numbering their members starting at 0
enum Color {Red, Green, Blue};
let c: Color = Color.Green;

// You can change this by manually setting the value of one of the members
enum Color {Red = 1, Green, Blue};
let c: Color = Color.Green;

// manually set them
enum Color {Red = 1, Green = 2, Blue = 4};
let c: Color = Color.Green;
						</code></pre>
					</section>

					<section>
						<h2>any</h2>
            <p>Allows to opt-out of type-checking and let the values pass through compile-time checks</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
let notSure: any = 4;
notSure = "maybe a string instead";
notSure = false; // okay, definitely a boolean

let list: any[] = [1, true, "free"];

list[1] = 100;
						</code></pre>
					</section>

					<section>
						<h2>void</h2>
            <p>Opposite of any: the absence of having any type at all</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
function warnUser(): void {
    alert("This is my warning message");
}

// Void variables are not useful because only undefined or null can be assigned to them:
let unusable: void = undefined;
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h1>Type assertions</h1>
            <p>When you know the type of some entity could be more specific than its current type</p>
            <p>Is like a type cast in other languages</p>
					</section>

					<section>
						<h2>Angle bracket syntax</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
let someValue: any = "this is a string";

let strLength: number = (&lt;string&gt;someValue).length;
						</code></pre>
					</section>

					<section>
            <h2><i>as</i> syntax</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
let someValue: any = "this is a string";

let strLength: number = (someValue as string).length;
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h1>Variable declarations</h1>
					</section>

					<section>
            <h2><i>var</i> declarations</h2>
            <p><i>var</i> declarations are accessible anywhere within their containing function, module, namespace, or global scope regardless of the containing block</p>
            <p>Some people call this var-scoping or function-scoping</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
function f(shouldInitialize: boolean) {
  if (shouldInitialize) {
    var x = 10;
  }

  return x;
}

f(true);  // returns '10'
f(false); // returns 'undefined'
            </code></pre>
					</section>

					<section>
            <h2><i>let</i> declarations</h2>
            <p>Use lexical-scoping or block-scoping</p>
            <p>Block-scoped variables are not visible outside of their nearest containing block or for-loop</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
function f(input: boolean) {
    let a = 100;

    if (input) {
        // Still okay to reference 'a'
        let b = a + 1;
        return b;
    }

    // Error: 'b' doesn't exist here
    return b;
}
						</code></pre>
					</section>

					<section>
            <h2><i>let</i> declarations</h2>
            <p>They can’t be read or written to before they’re actually declared</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
a++; // illegal to use 'a' before it's declared;
let a;
						</code></pre>
					</section>

					<section>
						<h2>Re-declarations and Shadowing 1</h2>
            <p>Valid with var</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
// All the x refer to same variable in function scope
function f(x) {
    var x;
    var x;

    if (true) {
        var x;
    }
}
						</code></pre>
					</section>

					<section>
						<h2>Re-declarations and Shadowing 2</h2>
            <p>Invalid with let</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
let x = 10;
let x = 20; // error: can't re-declare 'x' in the same scope

function f(x) {
    let x = 100; // error: interferes with parameter declaration
}

function g() {
    let x = 100;
    var x = 100; // error: can't have both declarations of 'x'
}
						</code></pre>
					</section>

					<section>
						<h2>Re-declarations and Shadowing 3</h2>
            <p>Redeclaration is valid if in a different nested block</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
function f(condition, x) {
    if (condition) {
        let x = 100;    // shadowing
        return x;
    }

    return x;
}

f(false, 0); // returns '0'
f(true, 0);  // returns '100'
						</code></pre>
					</section>

					<section>
						<h2><i>const</i> declarations 1</h2>
            <p>They are like let declaration</p>
						<p>Their value cannot be changed once they are bound</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
const numLivesForCat = 9;
						</code></pre>
					</section>

					<section>
						<h2><i>const</i> declarations 2</h2>
						<p>Doesn't mean that the values they refer to are immutable</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
const numLivesForCat = 9;
const kitty = {
    name: "Aurora",
    numLives: numLivesForCat,
}

// Error
kitty = {
    name: "Danielle",
    numLives: numLivesForCat
};

// all "okay"
kitty.name = "Rory";
kitty.name = "Kitty";
kitty.name = "Cat";
kitty.numLives--;
						</code></pre>
					</section>

					<section>
						<h2>let vs. const</h2>
            <p>Principle of least privilege: all declarations other than those you plan to modify should use const</p>
					</section>
				</section>

				<section>
					<section>
						<h1>Destructuring</h1>
            <p>The destructuring assignment syntax is an expression that makes it possible to extract data from arrays or objects into distinct variables</p>
					</section>

					<section>
						<h2>Arrays</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
let input = [1, 2];
let [first, second] = input;
console.log(first); // outputs 1
console.log(second); // outputs 2
						</code></pre>
					</section>

					<section>
						<h2>Existing variables</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
// swap variables
[first, second] = [second, first];
						</code></pre>
					</section>

					<section>
						<h2>Function parameters</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
function f([first, second]: [number, number]) {
    console.log(first);
    console.log(second);
}
f(input);
						</code></pre>
					</section>

					<section>
						<h2>rest parameters 1</h2>
            <p>You can create a variable for the remaining items in a list using the syntax ...name</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
let [first, ...rest] = [1, 2, 3, 4];
console.log(first); // outputs 1
console.log(rest); // outputs [ 2, 3, 4 ]
						</code></pre>
					</section>

					<section>
						<h2>rest parameters 2</h2>
            <p>You can ignore parameters</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
let [first] = [1, 2, 3, 4];
console.log(first); // outputs 1

let [, second, , fourth] = [1, 2, 3, 4];
						</code></pre>
					</section>

					<section>
						<h2>Object destructuring</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
let o = {
    a: "foo",
    b: 12,
    c: "bar"
}
let {a, b} = o; // This creates new variables a and b from o.a and o.b.
						</code></pre>
					</section>

					<section>
						<h2>Property renaming 1</h2>
            <p>You can also give different names to properties</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
let {a: newName1, b: newName2} = o;

// is equivalent to
let newName1 = o.a;
let newName2 = o.b;
						</code></pre>
					</section>

					<section>
						<h2>Property renaming 2</h2>
            <p>The type of the object needs to be written after the destructuring</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
let {a, b: newName}: {a: string, b: number} = o;
						</code></pre>
					</section>

					<section>
						<h2>Default values</h2>
            <p>Default values let you specify a default value in case a property is undefined</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
function keepWholeObject(wholeObject: {a: string, b?: number}) {
    let {a, b = 1001} = wholeObject;	// b will be 1001 if wholeObject.b is undefined
}
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h1>Interfaces</h1>
            <p>TypeScript's type-checking focuses on the shape that values have</p>
            <p>This is sometimes called "duck typing" or "structural subtyping"</p>
					</section>

					<section>
						<h2>Without interfaces</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
function printLabel(labelledObj: { label: string }) {
    console.log(labelledObj.label);
}

let myObj = {size: 10, label: "Size 10 Object"};
// myObj is checked based on its shape
// i.e. it has the same structure that function signature (label property)
printLabel(myObj);
						</code></pre>
					</section>

					<section>
						<h2>With an interface</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
interface LabelledValue {
    label: string;
}

function printLabel(labelledObj: LabelledValue) {
    console.log(labelledObj.label);
}

let myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj); // no need for myObj to implement the interface, only its shape matters
						</code></pre>
					</section>

					<section>
						<h2>Optional properties</h2>
						<p>Interfaces with optional properties are written similar to other interfaces, with each optional property denoted by a ? at the end of the property name in the declaration</p>
					</section>

					<section>
						<h2>Optional properties</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
interface SquareConfig {
    color?: string;
    width?: number;
}

function createSquare(config: SquareConfig): {color: string; area: number} {
    let newSquare = {color: "white", area: 100};
    if (config.color) {
        newSquare.color = config.color;
    }
    if (config.width) {
        newSquare.area = config.width * config.width;
    }
    return newSquare;
}

let mySquare = createSquare({color: "black"});
						</code></pre>
					</section>

					<section>
						<h2>Function types 1</h2>
						<p>Interfaces are also capable of describing function types</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
interface SearchFunc {
    (source: string, subString: string): boolean;
}
						</code></pre>
						<ul>
							<li>Is like a function declaration with only the parameter list and return type given</li>
							<li>Each parameter in the parameter list requires both name and type</li>
						</ul>
					</section>

					<section>
						<h2>Function types 2</h2>
						<p>Names of the parameters do not need to match</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
let mySearch: SearchFunc;
mySearch = function(src, sub) {
    let result = src.search(sub);
    if (result == -1) {
        return false;
    }
    else {
        return true;
    }
}
						</code></pre>
					</section>

					<section>
						<h2>Function types 3</h2>
						<p>Names of the parameters do not need to match</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
let mySearch: SearchFunc;
mySearch = function(src, sub) {
    let result = src.search(sub);
    if (result == -1) {
        return false;
    }
    else {
        return true;
    }
}
						</code></pre>
					</section>

					<section>
						<h2>Class types</h2>
						<p>Allows to explicitly enforce that a class meet a particular contract</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
interface ClockInterface {
    currentTime: Date;
    setTime(d: Date);
}

class Clock implements ClockInterface {
    currentTime: Date;
    setTime(d: Date) {
        this.currentTime = d;
    }
    constructor(h: number, m: number) { }
}
						</code></pre>
					</section>

					<section>
						<h2>Extending interfaces</h2>
						<p>An interface can extend multiple interfaces, creating a combination of all of the interfaces.</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
interface Shape {
    color: string;
}

interface Square extends Shape {
    sideLength: number;
}

let square = &lt;Square&gt;{};
square.color = "blue";
square.sideLength = 10;
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h1>Classes</h1>
					</section>

					<section>
						<h2>Class</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return "Hello, " + this.greeting;
    }
}

let greeter = new Greeter("world");
						</code></pre>
					</section>

					<section>
						<h2>Inheritance 1</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
class Animal {
    name: string;
    constructor(theName: string) { this.name = theName; }
    move(distanceInMeters: number = 0) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}

class Snake extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 5) {
        console.log("Slithering...");
        super.move(distanceInMeters);
    }
}

class Horse extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 45) {
        console.log("Galloping...");
        super.move(distanceInMeters);
    }
}
						</code></pre>
					</section>

					<section>
						<h2>Inheritance 2</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
let sam = new Snake("Sammy the Python");
let tom: Animal = new Horse("Tommy the Palomino");

sam.move();
tom.move(34);

outputs
Slithering...
Sammy the Python moved 5m.
Galloping...
Tommy the Palomino moved 34m.
						</code></pre>
					</section>

					<section>
						<h2>public modifier</h2>
						<p>Members are public by default</p>
					</section>

					<section>
						<h2>private modifier</h2>
						<p>When a member is marked private, it cannot be accessed from outside of its containing class</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
class Animal {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

new Animal("Cat").name; // Error: 'name' is private;
						</code></pre>
					</section>

					<section>
						<h2>protected modifier</h2>
						<p>Like the private modifier but protected members can also be accessed by instances of deriving classes</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
class Person {
    protected name: string;
    constructor(name: string) { this.name = name; }
}

class Employee extends Person {
    private department: string;

    constructor(name: string, department: string) {
        super(name);
        this.department = department;
    }

    public getElevatorPitch() {
        return `Hello, my name is ${this.name} and I work in ${this.department}.`;
    }
}

let howard = new Employee("Howard", "Sales");
console.log(howard.getElevatorPitch());
console.log(howard.name); // error
						</code></pre>
					</section>

					<section>
						<h2>Parameter properties</h2>
						<p>Let you create and initialize a member in one place</p>
						<p>Are declared by prefixing a constructor parameter with an accessibility modifier</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
class Animal {
    constructor(private name: string) { }
    move(distanceInMeters: number) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}
						</code></pre>
					</section>

					<section>
						<h1>Accessors</h1>
						<p>Intercepting accesses to a member of an object</p>
					</section>

					<section>
						<h2>No getter/setters</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
class Employee {
    fullName: string;
}

let employee = new Employee();
employee.fullName = "Bob Smith";
if (employee.fullName) {
    console.log(employee.fullName);
}
						</code></pre>
					</section>

					<section>
						<h2>With getter/setter</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
class Employee {
    private _fullName: string;

    get fullName(): string {
        return this._fullName;
    }

    set fullName(newName: string) {
        console.log("fullName changed");
        this._fullName = newName;
    }
}

let employee = new Employee();
employee.fullName = "Bob Smith";
if (employee.fullName) {
    console.log(employee.fullName);
}
						</code></pre>
					</section>

					<section>
						<h2>Static properties</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
class Grid {
    static origin = {x: 0, y: 0};
    calculateDistanceFromOrigin(point: {x: number; y: number;}) {
        let xDist = (point.x - Grid.origin.x);
        let yDist = (point.y - Grid.origin.y);
        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;
    }
    constructor (public scale: number) { }
}

let grid1 = new Grid(1.0);  // 1x scale
let grid2 = new Grid(5.0);  // 5x scale

console.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10}));
console.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10}));
						</code></pre>
					</section>

					<section>
						<h1>Abstract classes</h1>
						<p>Base classes from which other classes may be derived</p>
						<p>They may not be instantiated directly</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
abstract class Animal {
    abstract makeSound(): void;
    move(): void {
        console.log("roaming the earth...");
    }
}
						</code></pre>
					</section>

					<section>
						<h2>Abstract classes 1</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
abstract class Department {

    constructor(public name: string) {
    }

    printName(): void {
        console.log("Department name: " + this.name);
    }

    abstract printMeeting(): void; // must be implemented in derived classes
}
						</code></pre>
					</section>

					<section>
						<h2>Abstract classes 2</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
class AccountingDepartment extends Department {

    constructor() {
        super("Accounting and Auditing"); // constructors in derived classes must call super()
    }

    printMeeting(): void {
        console.log("The Accounting Department meets each Monday at 10am.");
    }

    generateReports(): void {
        console.log("Generating accounting reports...");
    }
}
						</code></pre>
					</section>

					<section>
						<h2>Abstract classes 3</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
let department: Department; // ok to create a reference to an abstract type
department = new Department(); // error: cannot create an instance of an abstract class
department = new AccountingDepartment(); // ok to create and assign a non-abstract subclass
department.printName();
department.printMeeting();
department.generateReports(); // error: method doesn't exist on declared abstract type
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h1>Functions</h1>
					</section>

					<section>
						<h2>Named functions</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
function add(x, y) {
    return x + y;
}
						</code></pre>
					</section>

					<section>
						<h2>Anonymous functions</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
let myAdd = function(x, y) { return x+y; };
						</code></pre>
					</section>

					<section>
						<h1>Typed functions</h1>
					</section>

					<section>
						<h2>Named functions</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
function add(x: number, y: number): number {
    return x + y;
}
						</code></pre>
					</section>

					<section>
						<h2>Anonymous functions</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
let myAdd = function(x: number, y: number): number { return x+y; };
						</code></pre>
					</section>

					<section>
						<h2>Full type of the function</h2>
						<p>It has two parts:</p>
						<ul>
							<li>the type of the arguments</li>
							<li>the return type</li>
						</ul>
						<p>Uses => to separate parameters and return type</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
let myAdd: (x: number, y: number)=>number =
    function(x: number, y: number): number { return x + y; };
						</code></pre>
					</section>

					<section>
						<h2>Types can be inferred</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
// myAdd has the full function type
let myAdd = function(x: number, y: number): number { return  x + y; };

// The parameters 'x' and 'y' have the type number
let myAdd: (baseValue:number, increment:number) => number =
    function(x, y) { return x + y; };
						</code></pre>
					</section>

					<section>
						<h1>Optional and default parameters</h1>
					</section>

					<section>
						<h2>Optional parameters 1</h2>
						<p>In TypeScript, every parameter is required</p>
						<p>The number of arguments given to a function has to match the number of parameters the function expects</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
function buildName(firstName: string, lastName: string) {
    return firstName + " " + lastName;
}

let result1 = buildName("Bob");                  // error, too few parameters
let result2 = buildName("Bob", "Adams", "Sr.");  // error, too many parameters
let result3 = buildName("Bob", "Adams"); 
						</code></pre>
					</section>

					<section>
						<h2>Optional parameters 2</h2>
						<p>In JavaScript, every parameter is optional</p>
						<p>We can get this functionality in TypeScript by adding a ? to the end of parameters</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
function buildName(firstName: string, lastName?: string) {
    if (lastName)
        return firstName + " " + lastName;
    else
        return firstName;
}

let result1 = buildName("Bob");                  // works correctly now
let result2 = buildName("Bob", "Adams", "Sr.");  // error, too many parameters
let result3 = buildName("Bob", "Adams");         // ah, just right
						</code></pre>
					</section>

					<section>
						<h2>Default parameters</h2>
						<p></p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
function buildName(firstName: string, lastName = "Smith") {
    return firstName + " " + lastName;
}

let result1 = buildName("Bob");                  // works correctly now, returns "Bob Smith"
let result2 = buildName("Bob", undefined);       // still works, also returns "Bob Smith"
let result3 = buildName("Bob", "Adams", "Sr.");  // error, too many parameters
let result4 = buildName("Bob", "Adams");         // ah, just right
						</code></pre>
					</section>

					<section>
						<h2>Rest parameters</h2>
						<p>Boundless number of optional parameters</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
function buildName(firstName: string, ...restOfName: string[]) {
    return firstName + " " + restOfName.join(" ");
}

let employeeName = buildName("Joseph", "Samuel", "Lucas", "MacKinzie");
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h1>Advanced Types</h1>
					</section>

					<section>
						<h2>Union types 1</h2>
						<p>A union type describes a value that can be one of several types</p>
						<p>We use the vertical bar (|) to separate each type</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
/**
 * Takes a string and adds "padding" to the left.
 * If 'padding' is a string, then 'padding' is appended to the left side.
 * If 'padding' is a number, then that number of spaces is added to the left side.
 */
function padLeft(value: string, padding: string | number) {
    // ...
}

let indentedString = padLeft("Hello world", true); // errors during compilation
						</code></pre>
					</section>

					<section>
						<h2>Union types 2</h2>
						<p>We can only access members that are common to all types in the union</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
interface Bird {
    fly();
    layEggs();
}

interface Fish {
    swim();
    layEggs();
}

function getSmallPet(): Fish | Bird {
    // ...
}

let pet = getSmallPet();
pet.layEggs(); // okay
pet.swim();    // errors
						</code></pre>
					</section>

					<section>
						<h2>Type aliases</h2>
						<p>Type aliases create a new name for a type</p>
						<p>Aliasing doesn’t actually create a new type - it creates a new name to refer to that type</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
type Name = string;
type NameResolver = () => string;
type NameOrResolver = Name | NameResolver;
function getName(n: NameOrResolver): Name {
    if (typeof n === "string") {
        return n;
    }
    else {
        return n();
    }
}
						</code></pre>
					</section>

					<section>
						<h2>String literal types</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
type Easing = "ease-in" | "ease-out" | "ease-in-out";
class UIElement {
    animate(dx: number, dy: number, easing: Easing) {
        // ...
    }
}

let button = new UIElement();
button.animate(0, 0, "ease-in");
button.animate(0, 0, "uneasy"); // error: "uneasy" is not allowed here
						</code></pre>
					</section>

					<section>
						<h2>Polymorphic <i>this</i> types</h2>
						<p>A polymorphic <span class="fragment highlight-blue">this</span> type represents a type that is the subtype of the containing class or interface</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
class BasicCalculator {
    public constructor(protected value: number = 0) { }
    public currentValue(): number {
        return this.value;
    }
    public add(operand: number): this {
        this.value += operand;
        return this;
    }
    public multiply(operand: number): this {
        this.value *= operand;
        return this;
    }
}

let v = new BasicCalculator(2).multiply(5).add(1).currentValue();

class ScientificCalculator extends BasicCalculator {
    public constructor(value = 0) {
        super(value);
    }
    public sin() {
        this.value = Math.sin(this.value);
        return this;
    }
}

let v = new ScientificCalculator(2).multiply(5).sin().add(1).currentValue();
						</code></pre>
					</section>

					<section>
						<h1>Symbols</h1>
						<p>Smbol is a primitive data type</p>
						<p>Symbol values are created by calling the Symbol constructor</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
let sym1 = Symbol();

let sym2 = Symbol("key"); // optional string key
						</code></pre>
					</section>

					<section>
						<h2>Symbols 2</h2>
						<p>Symbols are immutable and unique</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
let sym2 = Symbol("key");
let sym3 = Symbol("key");

sym2 === sym3; // false, symbols are unique
						</code></pre>
					</section>

					<section>
						<h2>Symbols 3</h2>
						<p>Symbols can be used as keys for object properties</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
let sym = Symbol();

let obj = {
    [sym]: "value"
};

console.log(obj[sym]); // "value"

// also for function members
const getClassNameSymbol = Symbol();

class C {
    [getClassNameSymbol](){
       return "C";
    }
}

let c = new C();
let className = c[getClassNameSymbol](); // "C"
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h1>Iterators</h1>
					</section>

					<section>
						<h1>Iterables</h1>
						<ul>
							<li>An object is deemed iterable if it has an implementation for the Symbol.iterator property</li>
							<li>Built-in types like Array, Map, Set, String, Int32Array, Uint32Array have it already implemented</li>
							<li>Symbol.iterator function on an object is responsible for returning the list of values to iterate on</li>
						<ul>
					</section>

					<section>
						<h2>for..of statements</h2>
						<p>Lops over an iterable object, invoking the Symbol.iterator property on the object</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
let someArray = [1, "string", false];

for (let entry of someArray) {
    console.log(entry); // 1, "string", false
}
						</code></pre>
					</section>

					<section>
						<h2>for..of vs for..in statements</h2>
						<p>for..in returns a list of <span class="fragment highlight-blue">keys</span> on the object being iterated</p>
						<p>for..of returns a list of <span class="fragment highlight-blue">values</span> of the numeric properties of the object being iterated.</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
let list = [4, 5, 6];

for (let i in list) {
   console.log(i); // "0", "1", "2",
}

for (let i of list) {
   console.log(i); // "4", "5", "6"
}
						</code></pre>
					</section>

					<section>
						<h2>for..of vs for..in statements</h2>
						<p><span class="fragment highlight-blue">for..in</span> operates on any object; it serves as a way to inspect its properties</p>
						<p><span class="fragment highlight-blue">for..of</span> is mainly interested in values of iterable objects</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
let pets = new Set(["Cat", "Dog", "Hamster"]);
pets["species"] = "mammals";

for (let pet in pets) {
   console.log(pet); // "species"
}

for (let pet of pets) {
    console.log(pet); // "Cat", "Dog", "Hamster"
}
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h1>Modules</h1>
					</section>

					<section>
						<h1>Modules</h1>
						<ul>
							<li>Starting with the ECMAScript 2015, JavaScript has a concept of modules</li>
							<li>They are executed within their own scope</li>
							<li>Variables, functions, classes, etc. declared in a module are not visible outside the module unless they are explicitly exported</li>
							<li>Modules are declarative</li>
							<li>The relationships between modules are specified in terms of imports and exports at the file level.</li>
							<li>Any file containing a top-level import or export is considered a module.</li>
						</ul>
					</section>

					<section>
						<h1>Loading modules</h1>
						<ul>
							<li>Modules import one another using a module loader</li>
							<li>At runtime the module loader is responsible for locating and executing all dependencies of a module before executing it</li>
							<li>CommonJS module loader for Node.js</li>
							<li>require.js for Web applications.</li>
						</ul>
					</section>

					<section>
						<h1>Export</h1>
					</section>

					<section>
						<h2>Exporting a declaration</h2>
						<p>Any declaration (variable, function, class, type alias, or interface) can be exported</p>
						<p>Use <span class="fragment highlight-blue">export</span> keyword.</p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
export let color = 'red';
export const PI = 3.1415;
						</code></pre>
					</section>

					<section>
						<h2>Single export</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
// StringValidator.ts
export interface StringValidator {
    isAcceptable(s: string): boolean;
}
						</code></pre>
					</section>

					<section>
						<h2>Multiple exports</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
// ZipCodeValidator.ts
export const numberRegexp = /^[0-9]+$/;

export class ZipCodeValidator implements StringValidator {
    isAcceptable(s: string) {
        return s.length === 5 && numberRegexp.test(s);
    }
}
						</code></pre>
					</section>

					<section>
						<h2>export statements</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
// ZipCodeValidator.ts
class ZipCodeValidator implements StringValidator {
    isAcceptable(s: string) {
        return s.length === 5 && numberRegexp.test(s);
    }
}
export { ZipCodeValidator };
export { ZipCodeValidator as mainValidator };
						</code></pre>
					</section>

					<section>
						<h2>Re-exports</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
export class ParseIntBasedZipCodeValidator {
    isAcceptable(s: string) {
        return s.length === 5 && parseInt(s).toString() === s;
    }
}

// Export original validator but rename it
export {ZipCodeValidator as RegExpBasedZipCodeValidator} from "./ZipCodeValidator";
						</code></pre>
					</section>

					<section>
						<h1>Import</h1>
					</section>

					<section>
						<h2>Import a single export from a module</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
import { ZipCodeValidator } from "./ZipCodeValidator";

let myValidator = new ZipCodeValidator();
						</code></pre>
					</section>

					<section>
						<h2>Renamed imports</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
import { ZipCodeValidator as ZCV } from "./ZipCodeValidator";
let myValidator = new ZCV();
						</code></pre>
					</section>

					<section>
						<h2>Import an entire module</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
import * as validator from "./ZipCodeValidator";
let myValidator = new validator.ZipCodeValidator();
						</code></pre>
					</section>

					<section>
						<h1>Default exports</h1>
						<ul>
							<li>Each module can optionally export a <span class="fragment highlight-blue">default</span> export</li>
							<li>there can only be one default export per module</li>
						</ul>
					</section>

					<section>
						<h2>Default export a class declaration</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
// ZipCodeValidator.ts
export default class ZipCodeValidator {
    static numberRegexp = /^[0-9]+$/;
    isAcceptable(s: string) {
        return s.length === 5 && ZipCodeValidator.numberRegexp.test(s);
    }
}

// test.ts
import validator from "./ZipCodeValidator";

let myValidator = new validator();
						</code></pre>
					</section>

					<section>
						<h2>Default export a function declaration</h2>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
// StaticZipCodeValidator.ts

const numberRegexp = /^[0-9]+$/;

export default function (s: string) {
    return s.length === 5 && numberRegexp.test(s);
}

// test.ts
import validate from "./StaticZipCodeValidator";

let strings = ["Hello", "98052", "101"];

// Use function validate
strings.forEach(s => {
  console.log(`"${s}" ${validate(s) ? " matches" : " does not match"}`);
});
						</code></pre>
					</section>

					<section>
						<h2>default export a value</h2>
						<p></p>
						<pre><code class="typescript" data-trim style="font-size: 18px;">
// OneTwoThree.ts
export default "123";

// Log.ts
import num from "./OneTwoThree";

console.log(num); // "123"
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h3>Exercise 1</h3>
            <p>Write a function that receives:</p>
            <ol>
              <li>number</li>
              <li>a boolean or a string</li>
              <li>a string or undefined</li>
              <li>returns a string</li>
            </ol>
					</section>
          <section>
						<h3>Exercise 2</h3>
            <p>Write a module that exports a Traveler class and TravelerType enum</p>
            <h4>The Traveler class has:</h4>
            <ul>
              <li>firstName, middleName, lastName and travelerType
              </li>
              <li>A getter for the full name as a string</li>
            </ul>
            <h4>The enum type contains:</h4>
            <ul>
              <li>Adult, Child</li>
            </ul>
					</section>
          <section>
						<h3>Exercise 3</h3>
            <p>Write a module that</p>
            <ul>
              <li>Imports Traveler and TravelerType</li>
              <li>Creates a traveler intance</li>
              <li>Write to console the traveler full name</li>
            </ul>
					</section>
				</section>

				<section>
					<section>
						<h3>Slides derived from</h3>
						<p><a href="https://www.typescriptlang.org/docs/">https://www.typescriptlang.org/docs/</a></p>
					</section>
					<section>
						<h3>Slides</h3>
						<p><a href="https://miguelcoba.github.io/typescript-intro">https://miguelcoba.github.io/typescript-intro</a></p>
						<h3>Source code</h3>
						<p><a href="https://github.com/miguelcoba/typescript-intro-code">https://github.com/miguelcoba/typescript-intro-code</a></p>
					</section>
				</section>

				<section>
						<h1>Thank you!</h1>
						<p>Miguel Cobá</p>
						<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
							<img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" />
						</a>
						<br />
						<small>This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</small>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
